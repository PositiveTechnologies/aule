# Stubs for antlr4.atn.ParserATNSimulator (Python 3.5)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any
from antlr4.atn.ATNSimulator import ATNSimulator

class ParserATNSimulator(ATNSimulator):
    debug = ...  # type: bool
    debug_list_atn_decisions = ...  # type: bool
    dfa_debug = ...  # type: bool
    retry_debug = ...  # type: bool
    parser = ...  # type: Any
    decisionToDFA = ...  # type: Any
    predictionMode = ...  # type: Any
    mergeCache = ...  # type: Any
    def __init__(self, parser, atn, decisionToDFA, sharedContextCache) -> None: ...
    def reset(self): ...
    def adaptivePredict(self, input, decision, outerContext): ...
    def execATN(self, dfa, s0, input, startIndex, outerContext): ...
    def getExistingTargetState(self, previousD, t): ...
    def computeTargetState(self, dfa, previousD, t): ...
    def predicateDFAState(self, dfaState, decisionState): ...
    def execATNWithFullContext(self, dfa, D, s0, input, startIndex, outerContext): ...
    def computeReachSet(self, closure, t, fullCtx): ...
    def removeAllConfigsNotInRuleStopState(self, configs, lookToEndOfRule): ...
    def computeStartState(self, p, ctx, fullCtx): ...
    def applyPrecedenceFilter(self, configs): ...
    def getReachableTarget(self, trans, ttype): ...
    def getPredsForAmbigAlts(self, ambigAlts, configs, nalts): ...
    def getPredicatePredictions(self, ambigAlts, altToPred): ...
    def getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(self, configs, outerContext): ...
    def getAltThatFinishedDecisionEntryRule(self, configs): ...
    def splitAccordingToSemanticValidity(self, configs, outerContext): ...
    def evalSemanticContext(self, predPredictions, outerContext, complete): ...
    def closure(self, config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon): ...
    def closureCheckingStopState(self, config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon): ...
    def closure_(self, config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon): ...
    def canDropLoopEntryEdgeInLeftRecursiveRule(self, config): ...
    def getRuleName(self, index): ...
    epsilonTargetMethods = ...  # type: Any
    def getEpsilonTarget(self, config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon): ...
    def actionTransition(self, config, t): ...
    def precedenceTransition(self, config, pt, collectPredicates, inContext, fullCtx): ...
    def predTransition(self, config, pt, collectPredicates, inContext, fullCtx): ...
    def ruleTransition(self, config, t): ...
    def getConflictingAlts(self, configs): ...
    def getConflictingAltsOrUniqueAlt(self, configs): ...
    def getTokenName(self, t): ...
    def getLookaheadName(self, input): ...
    def dumpDeadEndConfigs(self, nvae): ...
    def noViableAlt(self, input, outerContext, configs, startIndex): ...
    def getUniqueAlt(self, configs): ...
    def addDFAEdge(self, dfa, from_, t, to): ...
    def addDFAState(self, dfa, D): ...
    def reportAttemptingFullContext(self, dfa, conflictingAlts, configs, startIndex, stopIndex): ...
    def reportContextSensitivity(self, dfa, prediction, configs, startIndex, stopIndex): ...
    def reportAmbiguity(self, dfa, D, startIndex, stopIndex, exact, ambigAlts, configs): ...
